# VisualGeometry Python Examples

This directory contains comprehensive examples demonstrating the VisualGeometry Python interface with Julia backend integration.

## 🎯 Quick Start

Run any example directly:
```bash
cd python/examples
python plot_circle_ellipse_transform.py
```

## 📁 Examples Overview

### 🎨 Visualization Examples

#### `circle_to_ellipse_julia.py` ⭐ **Featured Example**
**Complete circle to ellipse transformation with Julia backend integration**

Demonstrates:
- Julia backend integration for high-performance point generation
- HomogeneousConic transformations using matrix operations
- Conversion between geometric representations (Circle ↔ Conic ↔ Ellipse)
- Professional matplotlib visualization with verification
- Numerical accuracy validation

```bash
python circle_to_ellipse_julia.py
```

**Output**: Interactive plot + `julia_circle_to_ellipse.png`

**Key Features**:
- Uses Julia `GeometryBasics.decompose` for 100-point circle generation
- Applies affine transformation (2x/1.5x scaling, 30° rotation, [1,2] translation)
- Converts Circle → HomogeneousConic → transformed → Ellipse
- Verifies transformation accuracy (typically < 1e-10 error)
- Creates 3-panel visualization showing complete pipeline

---

#### `demo_structure.py`
**Basic usage patterns and API demonstration**

Shows fundamental operations:
- Creating circles and ellipses
- Generating boundary points
- Basic coordinate transformations
- Property access and manipulation

```bash
python demo_structure.py
```

---

### 🔧 Technical Examples



---

#### `circle_to_ellipse_julia.py`
**Julia backend integration showcase**

Advanced example showing:
- Direct Julia function calls from Python
- Homogeneous coordinate transformations
- High-precision geometric computations
- Integration with scientific Python ecosystem

```bash
python circle_to_ellipse_julia.py
```

---

### 📊 Analysis Examples

#### `basic_usage.py`
**Simple API usage patterns**

Perfect for getting started:
- Creating geometric objects
- Generating points with different resolutions
- Basic property access
- Simple plotting

```bash
python basic_usage.py
```

---

#### `julia_backend_simulation.py`
**Backend comparison and simulation**

Educational example showing:
- How Julia backend improves performance
- Accuracy comparison between backends
- Fallback behavior simulation
- Performance benchmarking

```bash
python julia_backend_simulation.py
```

---

## 🚀 Running Examples

### Prerequisites
Ensure you have the Julia backend properly configured:

```bash
# Install Julia dependencies
julia -e 'using Pkg; Pkg.add(["CondaPkg", "PythonCall", "VisualGeometryCore"])'

# Configure Python environment
julia -e 'using CondaPkg; CondaPkg.add("python", version="3.11")'
julia -e 'using CondaPkg; CondaPkg.add_pip("numpy"); CondaPkg.add_pip("matplotlib")'
```

### Run All Examples
```bash
cd python/examples

# Featured visualization example
python plot_circle_ellipse_transform.py

# Test Julia backend integration
julia -e 'using Pkg; Pkg.test()'

# Basic usage patterns
python basic_usage.py

# Advanced Julia integration
python circle_to_ellipse_julia.py
```

### Troubleshooting
If you encounter OpenSSL issues, see: [`../../OPENSSL_TROUBLESHOOTING.md`](../../OPENSSL_TROUBLESHOOTING.md)

## 📈 Performance Expectations

With Julia backend properly configured:

| Operation | Julia Backend | Pure Python | Speedup |
|-----------|---------------|-------------|---------|
| Circle 64 points | ~50 μs | ~100 μs | ~2x |
| Ellipse 64 points | ~60 μs | ~150 μs | ~2.5x |
| Transformations | ~20 μs | ~30 μs | ~1.5x |

**Accuracy**: Julia backend provides machine precision (differences < 1e-15)

## 🎨 Visualization Gallery

### Circle to Ellipse Transformation
![Circle to Ellipse](../../docs/images/circle_ellipse_transformation.png)

*Generated by `plot_circle_ellipse_transform.py`*

**Features**:
- Original circle with Julia-generated points
- Transformed ellipse showing scale + rotation + translation
- Combined view with transformation arrow
- Detailed transformation statistics

### Multiple Geometries
```python
# Create complex scenes with multiple objects
geometries = [
    Circle([0, 0], 1.0),
    Circle([3, 1], 0.8), 
    Ellipse([1, 2], [1.5, 0.6], np.pi/3),
    Ellipse([-1, 1], [1.2, 0.9], -np.pi/4)
]

# Generate all points using Julia backend
all_points = [geom.points(64) for geom in geometries]
```

## 🔬 Advanced Usage Patterns

### Custom Transformation Pipeline
```python
from visualgeometry import Circle
import numpy as np

def create_transformation_sequence():
    """Demonstrate complex transformation sequences"""
    circle = Circle([0, 0], 1.0)
    points = circle.points(64)
    
    # Define transformation sequence
    transformations = [
        {'scale': [2.0, 1.5], 'rotation': 0, 'translation': [0, 0]},
        {'scale': [1.0, 1.0], 'rotation': np.pi/4, 'translation': [0, 0]},
        {'scale': [1.0, 1.0], 'rotation': 0, 'translation': [2, 1]}
    ]
    
    # Apply transformations sequentially
    current_points = points.copy()
    for i, transform in enumerate(transformations):
        # Apply transformation
        current_points = apply_transform(current_points, transform)
        
        # Plot intermediate result
        plt.subplot(2, 2, i+1)
        plt.plot(current_points[:, 0], current_points[:, 1], 'o-')
        plt.title(f'Step {i+1}')
        plt.axis('equal')
    
    plt.tight_layout()
    plt.show()
```

### Scientific Analysis Integration
```python
import pandas as pd
from scipy.spatial.distance import cdist
from sklearn.cluster import KMeans

def analyze_geometric_data():
    """Integrate with scientific Python ecosystem"""
    # Generate multiple geometries
    geometries = [Circle([i, j], 0.5) for i in range(3) for j in range(3)]
    
    # Collect all points
    all_points = np.vstack([geom.points(32) for geom in geometries])
    
    # Create DataFrame
    df = pd.DataFrame(all_points, columns=['x', 'y'])
    
    # Cluster analysis
    kmeans = KMeans(n_clusters=9)
    df['cluster'] = kmeans.fit_predict(all_points)
    
    # Statistical analysis
    stats = df.groupby('cluster').agg(['mean', 'std'])
    print("Cluster Statistics:")
    print(stats)
    
    # Visualization
    plt.scatter(df['x'], df['y'], c=df['cluster'], cmap='tab10')
    plt.title('Geometric Point Clustering')
    plt.show()
```

## 📚 Learning Path

### Beginner
1. Start with `basic_usage.py` - Learn fundamental operations
2. Run `demo_structure.py` - Understand API structure
3. Try `plot_circle_ellipse_transform.py` - See visualization capabilities

### Intermediate  
1. Study `circle_to_ellipse_julia.py` - Understand backend integration
2. Explore `circle_to_ellipse_transform.py` - Learn transformation math
3. Experiment with custom transformations

### Advanced
1. Analyze `circle_to_ellipse_julia.py` - Direct Julia integration
2. Create custom geometry pipelines
3. Integrate with scientific Python ecosystem
4. Contribute new examples!

## 🤝 Contributing Examples

We welcome new examples! Please follow these guidelines:

### Example Structure
```python
#!/usr/bin/env python3
"""
Brief description of what this example demonstrates

Detailed explanation of:
- Key concepts shown
- Prerequisites
- Expected output

Usage:
    python example_name.py
"""

import sys
sys.path.insert(0, '..')  # Add parent directory for imports

# Your example code here

if __name__ == "__main__":
    print("Example: [Name]")
    print("=" * 40)
    
    # Main example code
    
    print("✓ Example completed successfully!")
```

### Documentation Requirements
- Clear docstring explaining purpose
- Comments explaining key concepts
- Error handling for common issues
- Expected output description

### Submission Process
1. Create your example following the structure above
2. Test with both Julia backend and pure Python fallback
3. Add entry to this README
4. Submit pull request

---

**Happy coding with VisualGeometry!** 🚀✨