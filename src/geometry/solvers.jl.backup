# Geometric algorithm solvers (P3P, PnP, optimization)
# Includes polynomial solvers ported from PoseLib

# =============================================================================
# Polynomial Solvers
# =============================================================================

"""
    solve_quadratic_real(a, b, c)

Solve the quadratic equation a*x^2 + b*x + c = 0 for real roots.
Returns an array of real roots.

Uses numerically stable formulation to avoid cancellation errors.
"""
function solve_quadratic_real(a::Float64, b::Float64, c::Float64)
    b2m4ac = b^2 - 4 * a * c
    if b2m4ac < 0
        return Float64[]
    end

    sq = sqrt(b2m4ac)

    # Choose sign to avoid cancellations
    if b > 0
        root1 = (2 * c) / (-b - sq)
    else
        root1 = (2 * c) / (-b + sq)
    end

    root2 = c / (a * root1)

    return [root1, root2]
end

# Internal helper functions for P3P (not exported)
function root2real(b::Float64, c::Float64)
    Δ = b*b - 4.0*c
    if Δ < 0.0
        return Float64[]
    elseif Δ == 0.0
        return [-b/2.0]
    else
        sqrtΔ = sqrt(Δ)
        return [(-b + sqrtΔ)/2.0, (-b - sqrtΔ)/2.0]
    end
end

function solve_cubic_single_real(k2::Float64, k1::Float64, k0::Float64)
    # Depressed cubic t^3 + p t + q = 0 via s = t - k2/3
    a = k2
    p = k1 - a*a/3.0
    q = k0 - a*k1/3.0 + 2.0*a*a*a/27.0
    
    # Discriminant
    D = (q/2.0)^2 + (p/3.0)^3
    
    if D > 0
        # One real root
        u = cbrt(-q/2.0 + sqrt(D))
        v = cbrt(-q/2.0 - sqrt(D))
        t = u + v
        x = t - a/3.0
        return [x]
    elseif D == 0
        # Multiple roots
        if abs(q) < 1e-12
            return [-a/3.0]  # Triple root
        else
            u = cbrt(-q/2.0)
            return [2*u - a/3.0, -u - a/3.0]  # One single, one double
        end
    else
        # Three real roots (should not happen in our P3P case)
        rho = sqrt(-(p/3.0)^3)
        theta = acos(-q/(2.0*rho))
        rho_cbrt = cbrt(rho)
        return [2*rho_cbrt*cos(theta/3.0) - a/3.0,
                2*rho_cbrt*cos((theta + 2*π)/3.0) - a/3.0,
                2*rho_cbrt*cos((theta + 4*π)/3.0) - a/3.0]
    end
end

# PoseLib p3p formulation - compute cubic coefficients from angles and distances
# Based on PoseLib's specific parameterization
function compute_cubic_coeffs(c12::Float64, c13::Float64, c23::Float64,
                               a::Float64, b::Float64)
    # Intermediate values (PoseLib notation)
    m12sq = -c12*c12 + 1.0
    m02sq = -1.0 + c13*c13
    m01sq = -1.0 + c12*c12
    m013 = -2.0 + 2.0*c12*c13*c23

    bsq = b * b
    asq = a * a
    ab = a * b
    bsqm12sq = bsq * m12sq
    asqm12sq = asq * m12sq
    abm12sq = 2.0 * ab * m12sq

    k3_inv = 1.0 / (bsqm12sq + b * m02sq)
    k2 = k3_inv * ((-1.0 + a) * m02sq + abm12sq + bsqm12sq + b * m013)
    k1 = k3_inv * (asqm12sq + abm12sq + a * m013 + (-1.0 + b) * m01sq)
    k0 = k3_inv * (asqm12sq + a * m01sq)

    return k2, k1, k0
end

function refine_lambda!(λ::Vector{Float64}, a12::Float64, a13::Float64, a23::Float64,
                        b12::Float64, b13::Float64, b23::Float64)
    λ1, λ2, λ3 = λ[1], λ[2], λ[3]
    
    # Newton-Raphson refinement
    max_iterations = 10
    tolerance = 1e-12
    
    for iter in 1:max_iterations
        # Compute function values
        f1 = λ1^2 + λ2^2 - 2*λ1*λ2*a12 - b12
        f2 = λ1^2 + λ3^2 - 2*λ1*λ3*a13 - b13  
        f3 = λ2^2 + λ3^2 - 2*λ2*λ3*a23 - b23
        
        # Check convergence
        if abs(f1) < tolerance && abs(f2) < tolerance && abs(f3) < tolerance
            break
        end
        
        # Compute Jacobian
        J = @SMatrix [2*λ1 - 2*λ2*a12   2*λ2 - 2*λ1*a12   0.0;
                      2*λ1 - 2*λ3*a13   0.0                2*λ3 - 2*λ1*a13;
                      0.0                2*λ2 - 2*λ3*a23   2*λ3 - 2*λ2*a23]
        
        # Newton update
        f_vec = SVector{3,Float64}(f1, f2, f3)
        try
            δλ = -J \ f_vec
            λ1 += δλ[1]
            λ2 += δλ[2] 
            λ3 += δλ[3]
        catch
            # If Jacobian is singular, stop refinement
            break
        end
    end
    
    λ[1] = λ1
    λ[2] = λ2
    λ[3] = λ3
end

"""
    p3p(rays::AbstractVector, points_3d::AbstractVector) -> (rotations, translations)

Solve the Perspective-3-Point (P3P) problem to find camera poses.

Given 3 normalized image rays and their corresponding 3D points, compute possible
camera rotations and translations.

# Arguments
- `rays`: Vector of 3 normalized 3D ray directions from camera center
- `points_3d`: Vector of 3 corresponding 3D world points

# Returns
- `rotations`: Vector of possible rotation matrices (SMatrix{3,3,Float64})
- `translations`: Vector of possible translation vectors (Vec{3,Float64})
"""
function p3p(x_copy::AbstractVector{S}, X_copy::AbstractVector{T}) where {S <: StaticVector{3,Float64},T <: StaticVector{3,Float64}}
    Rs = Vector{SMatrix{3,3,Float64}}()
    ts = Vector{Vec{3,Float64}}()

    if length(x_copy) != 3 || length(X_copy) != 3
        return Rs, ts
    end

    # Work with copies to avoid modifying input
    x = [x_copy[1], x_copy[2], x_copy[3]]
    X = [X_copy[1], X_copy[2], X_copy[3]]

    # Normalize image rays (f in PoseLib)
    f = [normalize(x[1]), normalize(x[2]), normalize(x[3])]

    # Compute pairwise angles between image rays (cosines)
    c12 = dot(f[1], f[2])
    c13 = dot(f[1], f[3])
    c23 = dot(f[2], f[3])

    # Compute squared distances between 3D points
    X01 = X[1] - X[2]
    X02 = X[1] - X[3]
    X12 = X[2] - X[3]

    d01_sq = dot(X01, X01)
    d02_sq = dot(X02, X02)
    d12_sq = dot(X12, X12)

    # Normalize distances: reference is d12 (distance between points 2 and 3)
    # This matches the test data parameterization
    # a = d01/d12 (distance 1-2 relative to distance 2-3)
    # b = d02/d12 (distance 1-3 relative to distance 2-3)
    a = d01_sq / d12_sq
    b = d02_sq / d12_sq

    # For refine_lambda, use normalization by d02 (distance 1-3)
    b12 = d12_sq / d02_sq
    b13 = 1.0
    b23 = d01_sq / d02_sq

    # Compute cubic coefficients using PoseLib formulation
    k2, k1, k0 = compute_cubic_coeffs(c12, c13, c23, a, b)

    # Solve cubic equation for lambda1
    λ_roots = solve_cubic_single_real(k2, k1, k0)

    if isempty(λ_roots)
        return Rs, ts
    end

    # For each cubic root, solve for the full solution
    for λ1 in λ_roots
        # Solve 2x2 system for λ2, λ3 given λ1
        # From constraints: λ1² + λ2² - 2*λ1*λ2*c12 = b12
        #                   λ1² + λ3² - 2*λ1*λ3*c13 = b13
        A_23 = @SMatrix [1.0 - 2*λ1*c12   -2*λ1*c12;
                         -2*λ1*c13        1.0 - 2*λ1*c13]
        b_23 = SVector{2,Float64}(b12 - λ1^2, b13 - λ1^2)

        # Solve for [λ2², λ3²]
        try
            λ_sq = A_23 \ b_23
            λ2_sq = λ_sq[1]
            λ3_sq = λ_sq[2]

            # Take positive square roots (quadratic gives two solutions per root)
            roots_λ2 = root2real(0.0, -λ2_sq)
            roots_λ3 = root2real(0.0, -λ3_sq)

            # Try all combinations of signs
            for λ2 in roots_λ2
                for λ3 in roots_λ3
                    # Chirality check: all depths must be positive
                    if λ1 <= 0 || λ2 <= 0 || λ3 <= 0
                        continue
                    end

                    # Refine the solution with Newton-Raphson
                    λ = [λ1, λ2, λ3]
                    refine_lambda!(λ, c12, c13, c23, b12, b13, b23)

                    # Scale λ values by sqrt(d12_sq) to get actual depths
                    # (λ values from cubic are normalized by d12, the reference distance)
                    d0 = λ[1] * sqrt(d12_sq)
                    d1 = λ[2] * sqrt(d12_sq)
                    d2 = λ[3] * sqrt(d12_sq)

                    # Build rotation using PoseLib's difference vector approach
                    # Difference vectors in camera frame
                    v1_cam = d0 * f[1] - d1 * f[2]
                    v2_cam = d0 * f[1] - d2 * f[3]
                    v3_cam = cross(v1_cam, v2_cam)

                    # Build YY matrix: columns are [v1, v2, v1×v2]
                    YY = hcat(v1_cam, v2_cam, v3_cam)

                    # Corresponding difference vectors in world frame
                    # XX matrix: columns are [X01, X02, X01×X02]
                    v3_world = cross(X01, X02)
                    XX = hcat(X01, X02, v3_world)

                    # Rotation: R = YY * XX^(-1)
                    # (transforms difference vectors from world to camera frame)
                    try
                        R = YY * inv(XX)

                        # Ensure proper rotation (det(R) = 1)
                        if det(R) < 0
                            # Flip the third column to fix determinant
                            R = @SMatrix [R[1,1] R[1,2] -R[1,3];
                                         R[2,1] R[2,2] -R[2,3];
                                         R[3,1] R[3,2] -R[3,3]]
                        end

                        # Translation: t = d0*f[0] - R*X[0]
                        # (first point in camera frame minus rotated world position)
                        t = d0 * f[1] - R * X[1]

                        push!(Rs, SMatrix{3,3,Float64}(R))
                        push!(ts, Vec{3,Float64}(t))
                    catch
                        # Skip if XX is singular or other numerical issues
                        continue
                    end
                end
            end
        catch
            # Skip invalid solutions (singular A_23 matrix)
            continue
        end
    end

    return Rs, ts
end
